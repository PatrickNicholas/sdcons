// Copyright 2021 The sdcons Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![feature(map_first_last)]
#![feature(hash_drain_filter)]
#![feature(result_flattening)]

extern crate crc;
extern crate log;
extern crate serde;
extern crate serde_json;
extern crate tarpc;
extern crate thiserror;
#[macro_use]
extern crate tokio;
extern crate byteorder;
extern crate clap;
extern crate rocksdb;
extern crate sdcons;
extern crate tokio_serde;
extern crate toml;
#[macro_use]
extern crate static_assertions;

mod node;
mod service;
mod snap_down;

pub type DownloadBuilder = snap_down::DownloadBuilder<base::resolver::FileBasedResolver>;

use std::collections::{HashMap, HashSet};
use std::iter::FromIterator;
use std::sync::{atomic::Ordering, Arc, Mutex};
use std::{
    io,
    net::{IpAddr, SocketAddr},
};

use anyhow::Error;
use base::proto::{cons::Flusher, kv::Kv, snapshot::Snapshot};
use base::resolver::{AddressResolver, FileBasedResolver};
use base::sdk::flusher::MsgSender;
use base::sdk::FlusherChannelMap;
use base::slog::SimpleLogger;
use chrono::prelude::*;
use clap::{App, Arg};
use futures::{future, prelude::*};
use log::{error, info, warn};
use serde::Deserialize;
use tarpc::{
    context,
    server::{self, Channel, Incoming},
};
use tokio::time::{sleep, Duration};
use tokio_serde::formats::Json;

use crate::node::applier::FiniteStateMachine;
use crate::node::store::FSM;
use crate::node::{Node, NodeFuture};
use crate::service::{cons, kv, snapshot};

static LOGGER: SimpleLogger = SimpleLogger;

#[derive(Deserialize, serde::Serialize)]
struct Config {
    id: u64,
    kv_port: u16,
    cons_port: u16,
    snapshot_port: u16,
    named_file: String,
    snapshot_named_file: String,
    data_dir: String,
    wal_dir: String,
}

#[cfg(not(debug_assertions))]
fn config_argument() -> Arg<'static, 'static> {
    Arg::with_name("config")
        .short("c")
        .long("config")
        .takes_value(true)
        .default_value("/opt/tiger/simplekv/config.toml")
        .help("path of config file")
}

#[cfg(debug_assertions)]
fn config_argument() -> Arg<'static, 'static> {
    Arg::with_name("config")
        .short("c")
        .long("config")
        .takes_value(true)
        .default_value("config/debug.toml")
        .help("path of config file")
}

fn setup_tick(node: Arc<Mutex<Node<FSM>>>) {
    tokio::spawn(async move {
        loop {
            sleep(Duration::from_secs(1)).await;
            node.lock().unwrap().tick();
        }
    });
}

fn setup_node_advance(node: Arc<Mutex<Node<FSM>>>, sender: MsgSender<FileBasedResolver>) {
    tokio::spawn(async move {
        let future_node = NodeFuture::new(node);

        loop {
            let msgs = {
                let node = future_node.clone().await;
                let mut node = node.lock().unwrap();
                node.advance();
                node.take_messages()
            };
            for msg in msgs {
                if let Err(e) = sender.send(context::current(), msg).await {
                    warn!("send message: {}", e);
                }
            }
        }
    });
}

macro_rules! serve {
    ( $port:expr, $service:expr ) => {{
        use tarpc::serde_transport::tcp;
        let addr = SocketAddr::new(IpAddr::from([0, 0, 0, 0]), $port);
        tcp::listen(&addr, Json::default)
            .await?
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            .max_channels_per_key(100, |t| t.as_ref().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type
            // implementing the generated Service trait.
            .map(|channel| channel.requests().execute($service.clone().serve()))
            // Max 100 channels.
            .buffer_unordered(100)
            .for_each(|_| async {})
    }};
}

#[tokio::main]
async fn main() -> io::Result<()> {
    log::set_logger(&LOGGER)
        .map(|()| log::set_max_level(log::LevelFilter::Trace))
        .expect("init logger");

    let matches = App::new("exmaple/server")
        .version("v0.0.1")
        .author("PatrickNicholas")
        .about("simple kv server")
        .arg(config_argument())
        .get_matches();

    let config_file = matches.value_of("config").expect("config is required");
    let content = std::fs::read_to_string(config_file).expect("read config file failed");
    let config: Config = toml::from_str(&content).expect("read config from file");

    let mut opts = rocksdb::Options::default();
    opts.create_if_missing(true);
    let db = Arc::new(rocksdb::DB::open(&opts, config.data_dir).expect("open data dir"));
    let fsm = FSM::new(config.id, db.clone()).expect("open date dir");

    let resolver = FileBasedResolver::new(config.named_file);
    resolver.refresh().expect("resolve address");
    Node::<FSM>::build_if_not_exists(config.id, &config.wal_dir, resolver.ids())
        .expect("build init mark");

    let msg_sender = MsgSender::new(resolver.clone());

    let checkpoint_dir = format!("{}/checkpoint", config.wal_dir);
    let snapshot_resolver = FileBasedResolver::new(config.snapshot_named_file);
    snapshot_resolver.refresh().expect("resolve address");
    let download_builder =
        DownloadBuilder::new(config.id, checkpoint_dir.clone(), snapshot_resolver.clone());
    let node = Node::new(config.id, &config.wal_dir, fsm, download_builder).expect("reload node");
    let shared_node = Arc::new(Mutex::new(node));

    let simple_kv = kv::SimpleKv::new(db.clone());
    let service = kv::KvService::new(simple_kv.clone(), shared_node.clone());
    let sdcons_service = cons::SdconsService::new(shared_node.clone());
    let snapshot_service = snapshot::SnapshotService::new(checkpoint_dir);

    let (exit_flags, handler) = snapshot_service.setup_channel_recycle();

    setup_tick(shared_node.clone());
    setup_node_advance(shared_node.clone(), msg_sender);

    let cons_fut = serve!(config.cons_port, sdcons_service);
    let kv_fut = serve!(config.kv_port, service);
    let snapshot_fut = serve!(config.snapshot_port, snapshot_service);

    join!(kv_fut, cons_fut, snapshot_fut);

    exit_flags.store(true, Ordering::Release);
    handler.join().expect("join");

    io::Result::Ok(())
}
